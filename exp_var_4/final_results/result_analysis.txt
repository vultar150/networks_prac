+-------------------+---------------------------------+----------------------------+-------------------------------+
|    Эксперимент    | Алгоритм управления перегрузкой | Средняя скорость (Мбит/с)  | Средняя утилизация канала (%) |
+-------------------+---------------------------------+----------------------------+-------------------------------+
| backbone          | reno                            | 51.1                       | 4.65                          |
| backbone          | cubic                           | 122                        | 11                            |
| wireless          | reno                            | 16.1                       | 80.5                          |
| wireless          | cubic                           | 16.4                       | 82                            |
| mixed             | reno                            | 0.28                       | 1.4                           |
| mixed             | cubic                           | 0.61                       | 3                             |
+-------------------+---------------------------------+----------------------------+-------------------------------+


1. 
а) Фаза медленного старта - окно увеличивается экспоненциально (на 1 MSS после каждого ACK) до некоторого порога;
б) Фаза предотвращения перегрузки - линейный рост окна (на 1 / W за каждый ACK);
в) Фаза быстрой переотправки - после 3-ого дубликата ACK, окно W = (W/2), 
    на каждый дубликат ACK: W = W + 1, посылаем запрашиваемый сегмент после 3 дубля;
г) Фаза быстрого восстановления - используется совместно с фазой быстрой переотправки. После 
    фазы быстрого восстановления окно устанавливается равным половине окна от размера окна до 
    возникновения перегрузки.

В TCP Tahoe нет фазы бустрой переотправки и быстрого восстановления, из-за чего TCP Tahoe понижает 
размер окна до 1 после обнаружения перегрузки по таймауту и переходит в фазу медленного старта. 
Пороговое значение также устанавливается равным половине от предыдущего (до обнаружения перегрузки) 
максимального размера окна.

В TCP Cubic размер окна зависит только от последней перегрузки, окно меняется 
по закону кубической функции в зависимости от времени прошедшего с момента последней перегрузки и 
не зависит от RTT. Сначала рост окна происходит достаточно быстро (быстрее чем фаза медленного старта в TCP Tahoe), 
после чего размер окна становится предположительно таким, чтобы максимально использовать линию (окно начинает расти 
медленно; медленнее чем в TCP Tahoe), через некоторое время окно начинает увеличиваться, 
тем самым "прощупывая" свободную пропускную способность канала.
 

2. В магистральной сети TCP Reno слишком долго набирает скорость после фазы медленного старта (чтобы 
полностью заполнить пропускную способность канала нужно очень много времени), в то время 
как TCP Cubic на старте позволяет увеличивать размер окна гораздо быстрее. Несмотря на то, что 
в TCP Cubic есть промежуток времени, в котором окно растет слишком медленно, в конечном итоге скорость 
роста окна начинает стремительно расти. Оба алгоритма обнаруживают перегрузку по потере пакета.

В беспроводной сети ситуация обстоит иначе. В то время, как в магистральной сети канал достаточно надежный, 
и потерю пакета можно воспринимать как сигнал возникновения перегрузки, в беспроводной сети потеря 
пакета достаточно частое явление, которое происходит по различным причинам (коллизии, интерференция). 
Следовательно можно сделать вывод о том, что потеря пакетов в беспроводных сетях далеко не всегда являются следствием 
перегрузки. И, так как потери пакетов встречаются часто, то увеличивается и частота изменения размера окна. 
В следствие чего алгоритмы не сильно отличаются друг от друга, как можно заметить на графике.

3. Cubic выгоднее использовать на практике, так как он позволяет более эффективно использовать пропускную 
способность канала (по крайней мере в магистральных сетях).

4. Существует очень много различных алгоритмов управления перегрузкой. И все они не должны мешать 
друг другу, чтобы добиться справедливого распределения пропускной способности между пользователями сети.
Можно привести пример недружелюбных алгоритмов управления перегрузкой:
TCP Reno и алгоритм, который обнаруживает перегрузку по изменению задержки (например TCP Vegas). В то время, 
как TCP Reno отправляет пакеты в сеть, размер буфера начинает расти, вследствие чего увеличивается 
задержка, и TCP Vegas понижает размер окна (скорость оотправки), а TCP Reno продолжает наращивать скорость.
